--------------------------------------------------
PROJECT DEVLOG
--------------------------------------------------

=============================================================
PHASE 1 - ENVIRONMENT AND PROJECT SETUP
=============================================================

Status: COMPLETE


WHAT WAS ADDED
--------------
- Git repository initialized
- PyCharm project created
- Virtual environment (venv) created and activated
- Required libraries installed:
    numpy
    scipy
    matplotlib
    opencv-python
- requirements.txt generated using pip freeze
- Project folder structure created:
    src/
    data/
    data/test/
    output/
    reports/
    presentation/
- Global configuration file created:
    src/config.py
    (contains parameters and random seed)
- Environment test file created:
    test_env.py
- test_env.py executed successfully
- output/ folder confirmed working


WHAT WAS CHANGED
----------------
- No existing code modified (initial setup phase)


WHAT WAS NOT ADDED YET
----------------------
- No simulation engine implemented
- No robot dynamics implemented
- No numerical integrator implemented
- No visualization system implemented
- No path extraction implemented
- No swarm logic implemented
- No optical flow or video processing implemented
- No report or presentation created


NOTES
-----
- Python environment fully working
- All required libraries installed and confirmed
- Project reproducible via requirements.txt
- Folder structure ready for development
- Ready to begin Phase 2 (simulation engine)

=============================================================
END PHASE 1
=============================================================


=============================================================
PHASE 2 - CORE SIMULATION ENGINE + TESTING INFRASTRUCTURE
=============================================================

STATUS: COMPLETE AND VALIDATED

This phase implemented the full robot simulation engine, numerical solver,
visualization system, structured outputs, and automated testing framework.
All components were tested together and validated using system_tester.py.

NOTE (STRUCTURE FIX):
- The core engine now lives under src/core/ (package layout), but this section
  still describes the same functionality originally implemented in a single core module.


-------------------------------------------------------------
FILES ADDED
-------------------------------------------------------------

src/core/core.py
----------------
Main simulation engine containing:
- Robot state initialization
- Velocity clipping (speed limiting)
- Attraction force toward target
- Repulsion force between robots
- Damping force
- Total acceleration computation
- RK2 midpoint numerical integrator
- Full simulation loop / stepping utilities

Purpose:
Centralized all simulation logic into a stable core module.


utils/io_utils.py  (and/or src/utils/io_utils.py depending on runner imports)
----------------------------------------------------------------------------
Utilities for output and project path management:
- get_project_root()
- ensure_output_root()
- create_new_results_dir(output_root)

Purpose:
Automatically create incrementing results folders:
  output/results_0001/
  output/results_0002/
and manage file-safe paths.


(Visualization module)
----------------------
A visualization layer was added and later extended in Phase 3/4.
(Exact file location changed during refactors; functionality is preserved.)


system_tester.py
----------------
Global automated testing runner:
- Discovers all test files in src/test/
- Runs each test file
- Creates new results folder per run
- Stores test artifacts in:
    output/results_xxxx/tests/
- Prints readable PASS/FAIL output
- Returns exit code:
    0 = success
    2 = failure

Purpose:
Centralized quality-control system for entire project.


src/test/_test_utils.py
-----------------------
Testing helper context:
- Standardized PASS/FAIL/INFO printing
- Provides safe path creation inside results_dir
- Collects metrics

Purpose:
Improves readability and consistency across all tests.


src/test/test_dynamics_basic.py
-------------------------------
Primary Phase 2 validation test:
Tests:
1. Robot moves toward target
2. Speed never exceeds VMAX (true velocity check)
3. Repulsion increases separation between robots

Outputs:
- trajectory plots
- metrics printed
- PASS/FAIL status returned

Purpose:
Validates full simulation engine correctness.


TESTING BLUEPRINT DOCUMENT
--------------------------
A full text blueprint defining:
- Test discovery rules
- Test file structure
- Naming conventions
- Output conventions
- Example template

Purpose:
Ensures consistent test development across future phases.


-------------------------------------------------------------
FILES MODIFIED
-------------------------------------------------------------

src/config.py
-------------
Confirmed global parameters:
- DT
- VMAX
- KP
- KD
- KREP
- RSAFE
- ROBOT_RADIUS
- N_ROBOTS
- random seed

Used consistently across simulation and tests.


src/core/core.py (updates during phase)
---------------------------------------
- Replaced Euler integrator with RK2 midpoint integrator
- Ensured velocity clipping always applied
- Stabilized numerical behavior


-------------------------------------------------------------
SYSTEM FEATURES IMPLEMENTED
-------------------------------------------------------------

1. PHYSICS ENGINE
-----------------
- Multi-robot support
- Stable RK2 integration
- Collision avoidance via repulsion
- Velocity limiting
- Damping stabilization
- Target attraction

2. OUTPUT MANAGEMENT
--------------------
- Automatic creation of structured results folders
- Each run stored separately
- No overwriting of previous outputs

3. AUTOMATED TESTING
--------------------
- System-wide test discovery
- Standardized test format
- PASS/FAIL reporting
- Metrics logging
- Exit codes for validation

4. QUALITY CONTROL
------------------
All Phase 2 components tested together:
- Simulation correctness
- Velocity constraints
- Repulsion behavior
- Output generation
- Folder structure integrity

All tests passing.


-------------------------------------------------------------
WHAT WORKS NOW
-------------------------------------------------------------
- Full robot motion simulation (IVP system)
- RK2 numerical integration
- Multi-robot interaction
- Stable velocity constraints
- Visualization pipeline (basic)
- Structured output storage
- Automated test runner
- Reproducible simulation runs


-------------------------------------------------------------
NOTES
-------------------------------------------------------------
Phase 2 establishes the complete simulation core used by all
later phases.

All future work (path following, swarm coordination, pedestrian
navigation) will build on this engine without modifying its
fundamental structure.

Phase 2 is considered stable and complete.

=============================================================
END PHASE 2
=============================================================


=============================================================
PHASE 3 - MAP PROCESSING, SPLINE PATH & PHYSICS-BASED PATH FOLLOWING
=============================================================

STATUS: COMPLETE AND FULLY VALIDATED

This phase implemented the full path-extraction pipeline from map input to
physics-based robot path following with formal validation and visualization.

NOTE (STRUCTURE FIX):
- Path and controller modules now live under src/path/ (package layout).
- The devlog entries below refer to the same components; only paths changed.


-------------------------------------------------------------
FILES ADDED
-------------------------------------------------------------

src/map_tools/map_loader.py
--------------------------
Loads map image and provides access to map dimensions and pixel data.

Purpose:
Centralized map loading and validation for all later processing steps.


src/map_tools/map_click_ab.py
----------------------------
Interactive UI allowing user to select start (A) and end (B) points.

Features:
- Click A and B on map
- ESC cancel support
- Stores coordinates for reuse

Purpose:
Provides reproducible and user-controlled path endpoints.


src/path/path_extraction.py
--------------------------
Extracts walkable path from map image.

Features:
- Binary mask extraction
- Walkable region detection
- A/B validation inside path
- Centerline extraction from path mask

Purpose:
Transforms map image into navigable path representation.


src/path/centerline.py
----------------------
Processes extracted path mask to generate ordered centerline.

Features:
- Skeletonization of path
- Ordered centerline point extraction
- Ensures continuous path
- Debug visualization support

Purpose:
Creates geometric path backbone used for spline fitting.


src/path/spline_path.py
-----------------------
Builds continuous spline representation from centerline.

Features:
- Arc-length parameterized spline
- p(s): position along path
- tangent(s): unit tangent
- closest_s(x): nearest path coordinate
- Path length computation

Purpose:
Provides continuous path representation for controller and constraints.


src/path/path_controller.py
--------------------------
Moving-target path following controller.

Features:
- Progress parameter along spline
- Closest point projection
- Lookahead target generation
- Stable forward progression

Purpose:
Generates dynamic target for robot to follow spline smoothly.


src/path/constraints.py
-----------------------
Path boundary and corridor validation.

Features:
- distance_to_path()
- is_inside_path()
- Border violation measurement
- Corridor width handling

Purpose:
Ensures robot remains within walkable path region.


(Visualization utilities)
------------------------
Visualization utilities were extended to support:
- Map overlays
- Centerline rendering
- Path following animation / GIF export
- Validation plotting


-------------------------------------------------------------
FILES ADDED - TESTING
-------------------------------------------------------------

src/test/test_point_extraction.py
--------------------------------
Validates map loading, A/B selection, mask extraction, and centerline.

Outputs debug images for verification.


src/test/test_spline_path.py
----------------------------
Validates spline construction and geometry functions:
- Finite endpoints
- Normalized tangents
- closest_s correctness
- Spline length sanity


src/test/test_path_controller.py
--------------------------------
Validates controller outputs:
- Target numeric validity
- Progress initialization
- Stable parameter updates


src/test/test_constraints.py
----------------------------
Validates corridor logic:
- Distance to path correctness
- Inside/outside detection
- Border tolerance checks


src/test/test_path_following.py
-------------------------------
Simulates robot following spline using physics engine.

Confirms robot can follow entire path visually and numerically.


src/test/test_subproblem_1_validation.py
----------------------------------------
Formal validation of full system.

Checks:
- Robot reaches end of spline
- Stays within path borders
- Uses real RK2 physics
- Uses controller targets
- Progress measured via closest_s()

Simulation length automatically computed using:
- Path length
- VMAX
- DT

Ensures consistent validation independent of map.


src/test/test_visualization.py
------------------------------
Validates visualization pipeline and GIF export.


-------------------------------------------------------------
FILES MODIFIED
-------------------------------------------------------------

src/config.py
-------------
Added global path and map parameters:
- PATH_WIDTH / PATH_WIDTH_PIX
- Map path configuration
- A/B storage behavior
- Controller tuning values

Ensures consistent configuration across modules.


system_tester.py
----------------
Now runs full Phase 3 test suite automatically.

Produces:
output/results_xxxx/tests/

with all debug images and animations.


-------------------------------------------------------------
SYSTEM FEATURES IMPLEMENTED
-------------------------------------------------------------

1. MAP -> PATH PIPELINE
-----------------------
Map image -> mask -> centerline -> spline -> controller -> robot motion


2. CONTINUOUS SPLINE PATH
-------------------------
Arc-length parameterized path
Closest-point projection
Smooth tangents
Lookahead targeting


3. PHYSICS-BASED PATH FOLLOWING
-------------------------------
Robot follows spline using real RK2 dynamics
NOT kinematic teleporting
Fully compatible with Phase 2 engine


4. PATH CONSTRAINT VALIDATION
-----------------------------
Distance-to-path checks
Inside/outside detection
Border violation metrics


5. FORMAL SYSTEM VALIDATION
---------------------------
Automated test confirms:
- Robot reaches goal
- Remains inside corridor
- Simulation stable for full path
- Works across multiple A/B selections


6. VISUAL DEBUGGING
-------------------
Generated artifacts:
- Centerline debug images
- Mask overlays
- Path following plots
- Validation plots
- GIF animations


-------------------------------------------------------------
WHAT WORKS NOW
-------------------------------------------------------------

- Map loading and validation
- Interactive A/B selection
- Path mask extraction
- Centerline extraction
- Continuous spline generation
- Moving-target path controller
- Physics-based robot following
- Corridor constraint enforcement
- Full visualization pipeline
- Automated multi-stage testing
- Formal path-following validation


-------------------------------------------------------------
NOTES
-------------------------------------------------------------
Phase 3 completes the full single-robot navigation pipeline from
map input to validated path following using real physics.

All modules are now stable, integrated, and tested through the
system tester.

Phase 3 is considered COMPLETE and STABLE.

=============================================================
END PHASE 3
=============================================================


=============================================================
PHASE 4 - TWO-WAY SWARM SIMULATION, COLLISION HANDLING, AND VISUALIZATION
=============================================================

STATUS: COMPLETE AND VALIDATED (system_tester green on full suite)

This phase extended the project from single-robot path following to a
multi-robot swarm traveling in BOTH directions on the same corridor.
It added spawn logic, two-way control (A->B and B->A simultaneously),
collision detection, border repulsion integration for swarms, tuning tools,
a clean two-way visualization (GIF), and a full Phase 4 test suite.

-------------------------------------------------------------
FILES ADDED
-------------------------------------------------------------

src/swarm/__init__.py
--------------------
Swarm package initializer.


src/swarm/spawn.py
------------------
Swarm spawning and initialization utilities.

What it provides (canonical API expected by tests/runners):
- spawn_swarm_state(spline, N=None, seed=None)
    returns (positions, velocities, groups)
- spawn_swarm_positions(spline, N=None, seed=None)
    returns (positions, groups)
- spawn_swarm_near_A_B(spline, N=None, seed=None, return_velocities=True)
    returns (positions, velocities, groups) or (positions, groups)

Implementation details:
- Spawns N/2 robots near s ~ 0 (A-side) and N/2 near s ~ L (B-side)
- Randomizes across corridor width using spline normal
- Optionally enforces corridor validity via is_inside_path() if available
- Velocities are initialized to EXACTLY zero


src/swarm/collisions.py
-----------------------
Collision detection utility:
- detect_collisions(positions)
Returns colliding robot index pairs (and distances) based on ROBOT_RADIUS / RSAFE rules.


src/swarm/sim.py
----------------
Swarm simulation entry points:

- ReversedSpline wrapper:
  Allows reuse of PathController for B->A by reversing arc-length parameter.

- simulate_swarm_oneway_A_to_B(...)
- simulate_swarm_oneway_B_to_A(...)
- simulate_swarm_twoway(...)

Key behaviors:
- Per-robot PathController targets
- RK2 integration via core engine
- Border repulsion force applied during swarm stepping
- Optional collision logging support (backward-compatible flags)


src/swarm/viz_swarm.py
----------------------
Two-way swarm visualization renderer.

What it renders:
- Spline centerline
- Optional corridor bounds (inner borders accounting for robot radius)
- A->B robots and B->A robots as separate scatter groups
- Collision highlight rings (if collisions occur)
- Collision counter text overlay
- Trailing motion traces for readability
- GIF export (implemented in a memory-safe way to avoid storing all frames)


-------------------------------------------------------------
FILES ADDED (RUNNERS / SCRIPTS)
-------------------------------------------------------------

run_phase4_tuning.py
--------------------
Batch/tuning script used to sweep N and/or parameters and log:
- collision counts
- first collision timestep
Used to find settings that reach "collision count = 0".


run_phase4_visualize.py
-----------------------
Generates a polished two-way swarm visualization GIF for the checkbox:
- Spawns robots near A and B
- Runs two-way simulation
- Exports GIF to a results folder


run_phase4_demo.py
------------------
Convenience demo runner to quickly showcase the phase 4 behavior
(without running the full system tester).


run_all.py
----------
Convenience entry point to run a full pipeline (optional helper).


-------------------------------------------------------------
FILES ADDED - TESTING (PHASE 4 SUITE)
-------------------------------------------------------------

src/test/test_swarm_spawn.py
---------------------------
Validates:
- Correct shapes
- Correct group split (+1 then -1)
- A-side closer to A than B, B-side closer to B than A
- Spawn has variation (not degenerate)
- Optional inside-path check
Saves: swarm_spawn_debug.png


src/test/test_swarm_initial_velocities.py
----------------------------------------
Validates:
- spawn_swarm_state returns velocities all exactly zero


src/test/test_swarm_oneway_A_to_B.py
-----------------------------------
Validates:
- A-side robots make strong forward progress along spline (mean s increases)
Saves: swarm_oneway_A_to_B.png


src/test/test_swarm_oneway_B_to_A.py
-----------------------------------
Validates:
- B-side robots make strong backward progress (mean s decreases in original frame)
Saves: swarm_oneway_B_to_A.png


src/test/test_swarm_repulsion.py
-------------------------------
Validates:
- Repulsion increases separation when robots start too close


src/test/test_border_repulsion.py
--------------------------------
Validates:
- Border force is ~0 inside corridor
- Near-border force pushes inward (dot(force, outward_normal) < 0)


src/test/test_swarm_twoway_same_timestep.py
------------------------------------------
Validates:
- Both A->B and B->A groups move on the FIRST timestep
Requires:
- simulate_swarm_twoway(..., log_collisions=True) to be accepted


src/test/test_swarm_twoway_inside_corridor.py
---------------------------------------------
Validates:
- Two-way swarm stays inside corridor (>= 98% sampled points inside)
Saves: twoway_outside_counts.png


src/test/test_swarm_twoway_no_collisions.py
-------------------------------------------
Validates:
- Both groups progress correctly in opposite directions
- No collisions (sampled) and min distance stays safe
Saves: twoway_progress_mean_s.png


src/test/test_swarm_twoway_gif_export.py
---------------------------------------
Validates:
- Two-way swarm GIF is exported
- File exists and is non-trivial in size (> 50KB)
Prints progress while writing frames (memory-safe export)


-------------------------------------------------------------
FILES MODIFIED (IMPORTANT FIXES / INTEGRATION)
-------------------------------------------------------------

src/path/constraints.py
-----------------------
- Updated inside/outside logic to be orientation-independent:
  "offset inside" and "far outside" checks now work regardless of normal sign.
- Stabilized distance-to-path and inside-path consistency used by swarm tests.


src/map_tools/map_click_ab.py  and A/B persistence behavior
----------------------------------------------------------
- Fixed the selection UI behavior to prevent repeatedly re-opening after choosing A and B.
- Added/confirmed A/B persistence via:
    data/ab_points.json
- Added/confirmed FORCE_AB_RESELECT behavior:
  If FORCE_AB_RESELECT=True, UI forces a fresh selection and then auto-resets to False
  so tests/runs do not keep prompting in the same run.


utils/io_utils.py (and/or src/utils/io_utils.py)
-----------------------------------------------
- Confirmed create_new_results_dir(output_root) signature.
- Updated runners to pass output_root returned by ensure_output_root().


src/swarm/sim.py
----------------
- Removed earlier duplicate/overlapping definitions and standardized outputs.
- Ensured simulation functions always return homogeneous numpy arrays:
    traj shape = (steps+1, N, 2)
- Added backward-compatible argument support:
    log_collisions (accepted by tests)
    return_collision_log / collision logging support


src/swarm/viz_swarm.py
----------------------
- Improved robustness:
  - Converts inputs to numpy arrays with strict shapes
  - Corridor bounds computed from spline tangents
- Improved aesthetics:
  - Clear legend, grid, equal aspect
  - Direction-separated robot colors
  - Trails + collision rings + counters
- Fixed GIF export stability (avoids MemoryError by not keeping all frames in memory)


src/config.py
-------------
- Added/confirmed Phase 4 parameters used by swarm:
  - PATH_WIDTH / PATH_WIDTH_PIX
  - ROBOT_RADIUS, RSAFE, KREP
  - N_ROBOTS
  - SPAWN_MARGIN (optional)
  - SPAWN_S_SPAN (optional)
  - FORCE_AB_RESELECT (A/B UI forcing)


-------------------------------------------------------------
SYSTEM FEATURES IMPLEMENTED
-------------------------------------------------------------

1. TWO-WAY SWARM MOTION
-----------------------
- Half robots travel A->B, half travel B->A simultaneously
- B->A implemented by reversing spline parameterization (ReversedSpline)
- Same timestep start for both groups (validated)


2. SWARM INITIALIZATION
-----------------------
- Deterministic seeding support
- Spawns near endpoints with corridor-normal offsets
- Initial velocities always exactly zero (validated)


3. BORDER COMPLIANCE
--------------------
- Border repulsion integrated into swarm stepping
- Swarm stays within corridor at high sampled ratio (validated)


4. COLLISION DETECTION AND AVOIDANCE
------------------------------------
- Collision detection (pairs) available each frame
- Repulsion and parameter tuning used to achieve collision count = 0 in runs/tests


5. SWARM VISUALIZATION
----------------------
- Two-way GIF shows:
  - both-direction motion
  - optional corridor overlay
  - collision circles + collision counter
  - trails for readability
- Export designed to be stable for longer simulations


6. PHASE 4 TEST COVERAGE
------------------------
- Full automated test suite added for:
  spawn, velocities, oneway progress, two-way progress, corridor adherence,
  collision behavior, border force correctness, same-timestep start, GIF export


-------------------------------------------------------------
WHAT WORKS NOW
-------------------------------------------------------------
- A/B selection and persistence
- Single-robot validated path following (Phase 3)
- Multi-robot swarm spawning at both ends
- Two-way swarm simulation (A->B and B->A together)
- Border repulsion for swarms
- Collision detection and tuning pipeline
- Two-way visualization on the map with exportable GIF
- Full system_tester run producing clean artifacts in output/results_xxxx/tests/


-------------------------------------------------------------
NOTES
-------------------------------------------------------------
- The project now follows a clear package layout:
    src/core/
    src/path/
    src/map_tools/
    src/swarm/
    src/test/
- output folder naming is now consistently "output/" (not "outputs/").
- A/B points persist in data/ab_points.json to avoid repeated UI prompts.
- FORCE_AB_RESELECT can be toggled to force a fresh A/B selection when needed.

=============================================================
END PHASE 4
=============================================================

=============================================================
PHASE 5 - PEDESTRIAN FLOW NAVIGATION (VIDEO + OPTICAL FLOW + REPULSION)
=============================================================

STATUS: COMPLETE (FUNCTIONAL) + TUNABLE
(End-to-end pipeline exists: video -> flow/detection/tracking -> robot mission runs -> saved overlays + logs.
Final behavior quality depends on tuning P5_* parameters.)

-------------------------------------------------------------
FILES ADDED
-------------------------------------------------------------

src/phase5/video_frames.py
--------------------------
Frame extraction pipeline for pedestrian videos.

What it provides:
- extract_frames(...):
  - loads a video from /data (or passed path)
  - samples frames with stride and optional max_seconds
  - optional resizing (keeps aspect ratio)
  - writes frames into the current results_dir
  - returns metadata:
      frames_dir, frame_paths, fps, out_hw, etc.

Purpose:
Creates a deterministic, test-friendly frame sequence for optical flow + missions.


src/phase5/optical_flow.py
--------------------------
Dense optical flow utilities (OpenCV).

What it provides:
- compute_dense_flow(prev_gray, next_gray, method="farneback"/"dis")
- optional helpers for:
  - saturation / clipping
  - flow visualization (HSV)
  - saving per-step flow fields (.npy) and debug images

Purpose:
Produces the dense (u,v) velocity field used by the robot and stored for proof/debug.


src/phase5/ped_detect.py
------------------------
Background-subtraction based pedestrian detection (MOG2).

What it provides:
- PedestrianDetectorMOG2(...)
- detect(frame) -> bounding boxes
- boxes_to_centroids(boxes) -> (N,2)

Purpose:
Obtains pedestrian positions (x_j(t)) used for repulsion and tracking.


src/phase5/ped_track.py
------------------------
Rough pedestrian tracking to keep IDs stable over short time windows.

What it provides (typical):
- NearestNeighborTracker(...) or similar
- update(boxes, centroids) -> tracks with IDs + filtered centroids

Purpose:
Stabilizes detections frame-to-frame so repulsion uses smoother point sets and
the video overlay is readable (IDs don’t reset every frame).


src/phase5/repulsion.py
-----------------------
Pedestrian repulsion model.

What it provides:
- repulsion_force(robot_xy, points, rsafe, krep, gamma, max_force, ...)
- min_distance(robot_xy, points)

Purpose:
Computes the avoidance term pushing the robot away from pedestrian centroids and
logs minimum safety distance over time.


src/phase5/missions.py
----------------------
Mission definitions (start/goal for video navigation).

What it provides:
- make_mission_left_to_right(H,W,...)
- make_mission_right_to_left(H,W,...)
- Mission dataclass (name, start_xy, goal_xy)

Purpose:
Standardizes the two required runs:
  1) left -> right
  2) right -> left


src/phase5/vt_dynamics.py
-------------------------
VT (velocity tracking) dynamics integrator utilities.

What it provides:
- VTParams(...) container (kv, kd, rsafe, krep, etc.)
- vt_derivative(state, flow, ped_points_t, params, goal_xy)
- rk2_step(...) for stable integration

Purpose:
Separates dynamics math from mission runner logic and provides testable,
stable numerical integration.


src/phase5/run_missions.py   (or equivalent runner under src/phase5/)
---------------------------------------------------------------------
Full Phase 5 mission runner used by tests and demos.

What it produces per mission:
- overlay video (.mp4)
- trajectory CSV (x,y,vx,vy over time)
- min-distance CSV (robot->pedestrian minimum distance over time)
- summary TXT with key settings + metrics

Purpose:
One command to generate the Subproblem 3 deliverables.


-------------------------------------------------------------
FILES ADDED - TESTING (PHASE 5 SUITE)
-------------------------------------------------------------

src/test/test_phase5_video_frames.py
------------------------------------
Validates:
- frames extracted inside results_dir
- resizing works
- at least a few frames exist
- metadata sanity


src/test/test_phase5_optical_flow.py
------------------------------------
Validates:
- flow fields are computed + stored (.npy)
- saturation is respected
- flow is non-trivial (not all zero)
- visualization artifacts are produced


src/test/test_phase5_dense_flow.py
----------------------------------
Validates:
- dense flow shape/dtype/finiteness
- saves a flow visualization and raw flow field


src/test/test_phase5_ped_detect.py
---------------------------------
Validates:
- MOG2 detection returns in-bounds boxes + centroids
- avoids pathological “giant blob” passing silently
- saves a debug overlay image


src/test/test_phase5_ped_track.py
---------------------------------
Validates:
- tracker keeps at least one ID persistent across frames
- saves a debug overlay with IDs


src/test/test_phase5_repulsion.py
---------------------------------
Validates:
- repulsion magnitude increases when robot is closer to a pedestrian
- repulsion finite (no NaN/inf)
- saves a debug overlay showing repulsion vectors


src/test/test_phase5_missions.py
--------------------------------
Validates:
- two missions exist (L->R and R->L)
- start/goal are in-bounds and directions are correct
- saves a debug overlay with start/goal markers


src/test/test_phase5_vt_dynamics.py
-----------------------------------
Validates:
- VT integration tracks a constant flow field stably
- repulsion acceleration pushes away in the correct direction


-------------------------------------------------------------
FILES MODIFIED
-------------------------------------------------------------

src/config.py
-------------
Added Phase 5 configuration section (single source of truth for video navigation):
- video inputs (P5_VIDEO_FILENAME)
- resizing + stride + max_seconds (fast tests vs real runs)
- optical flow method + saturation cap (P5_FLOW_METHOD, P5_VMAX)
- detection parameters (MOG2 + morphology thresholds)
- tracking parameters (gate + miss count)
- robot geometry in pixels (P5_ROBOT_RADIUS_PIX)
- pedestrian safety + repulsion parameters (P5_RSAFE_PIX, P5_KREP_PED, etc.)
- VT dynamics gains (P5_KV, P5_KD)
- goal bias parameters (P5_W_GOAL, P5_GOAL_SPEED)

Purpose:
Makes Phase 5 tunable without touching code.


-------------------------------------------------------------
SYSTEM FEATURES IMPLEMENTED
-------------------------------------------------------------

1. VIDEO -> FRAMES PIPELINE
---------------------------
- Deterministic frame extraction into results folders
- Supports stride + max_seconds + resizing for fast tests


2. DENSE OPTICAL FLOW FIELD
---------------------------
- Computes flow between consecutive frames
- Supports method switch (Farneback / DIS if implemented)
- Supports saturation/clipping to keep dynamics stable


3. PEDESTRIAN DETECTION + TRACKING
----------------------------------
- Background subtraction (MOG2) detection
- Centroid extraction
- Rough NN tracking to stabilize IDs and point motion


4. ROBOT NAVIGATION IN FLOW WITH AVOIDANCE
------------------------------------------
- Robot follows local flow + goal bias
- Repulsion keeps distance from detected pedestrians
- Integrated with stable RK2 stepping and velocity clipping


5. ARTIFACT EXPORT FOR SUBPROBLEM 3
-----------------------------------
- Two mission videos (L->R, R->L)
- CSV logs for trajectory and minimum distance
- Debug overlays (detections, tracks, flow arrows, robot, start/goal)


-------------------------------------------------------------
WHAT WORKS NOW
-------------------------------------------------------------

- Subproblem 3 pipeline runs end-to-end:
  video -> frames -> flow -> pedestrian points -> robot motion -> saved artifacts
- Tests exist for each component (frames, flow, detection, tracking, repulsion, missions, VT dynamics)
- All Phase 5 outputs are stored neatly in results folders

-------------------------------------------------------------
NOTES
-------------------------------------------------------------

- Behavior is highly dependent on tuning (repulsion vs goal bias vs vmax).
- Unit consistency is critical:
  optical flow is px/frame and must be converted internally to px/sec.
- For long videos, flow caching can drastically reduce rerun time.

=============================================================
END PHASE 5
=============================================================



=============================================================
PHASE 6 - FINAL VALIDATION / SUBPROBLEM PACKAGING + CHECKBOX DELIVERABLES
=============================================================

STATUS: INTEGRATED AND RUNNABLE
(Validation-style runs produce neatly organized outputs per subproblem inside a single results folder.)

-------------------------------------------------------------
FILES ADDED
-------------------------------------------------------------

run_phase6_validation.py   (or equivalent validation runner script)
---------------------------------------------------------------
High-level “final validation” runner that:
- creates a new output/results_XXXX folder
- runs the required subproblem pipelines (or their validating tests)
- stores artifacts in:
    output/results_XXXX/phase6_validation/subproblem1/
    output/results_XXXX/phase6_validation/subproblem2/
    output/results_XXXX/phase6_validation/subproblem3/

Purpose:
One command that generates everything needed for final submission evidence.


Phase 6 validation output writers (generated artifacts)
------------------------------------------------------
The validation run stores (at minimum):
- images / plots / GIFs
- per-subproblem metrics.json
- readable explanation .txt files for failures or warnings

Example observed Subproblem 3 artifacts:
- sub3_camera_motion_failure_demo.png
- sub3_camera_motion_failure_explanation.txt
- sub3_metrics.json

Purpose:
Provides a clean “proof bundle” for grading and debugging.


-------------------------------------------------------------
FILES MODIFIED
-------------------------------------------------------------

system_tester.py  (or overall runner entry point)
-------------------------------------------------
Extended / organized to support a “Phase 6 validation style run”:
- runs grouped checks per subproblem
- stores outputs in a predictable folder layout
- prints compact PASS/FAIL summary and saves metrics


src/test/*  (test suite integration updates)
--------------------------------------------
Phase 6 uses the existing test modules as “checkbox validators”.
The suite now covers:
- Subproblem 1: map->mask->centerline->spline->path-following validation + visualization
- Subproblem 2: two-way swarm progress + corridor adherence + collision checks + GIF export
- Subproblem 3: video missions + safety distance tracking + saved overlay videos

Purpose:
Ensures the final deliverables match the rubric and are reproducible.


src/config.py
-------------
Confirmed separation of:
- fast test settings (short max_seconds / higher stride)
- real run settings (full video / stride 1)

Purpose:
Validation runs stay quick, while real runs generate full-quality deliverables.


-------------------------------------------------------------
SYSTEM FEATURES IMPLEMENTED
-------------------------------------------------------------

1. SUBPROBLEM-ORIENTED VALIDATION
---------------------------------
Instead of “phase-by-phase” only, the runner validates by rubric task:
- Subproblem 1 artifacts + correctness checks
- Subproblem 2 swarm safety + visualization
- Subproblem 3 video navigation + safety distance logs


2. NEAT OUTPUT PACKAGING
------------------------
- Standardized folder structure per subproblem
- No overwriting: each run creates a new results_XXXX folder
- Metrics saved as JSON for quick inspection and reporting


3. FAILURE DEMOS + EXPLANATIONS (WHERE APPLICABLE)
--------------------------------------------------
When something fails (ex: safety distance below Rsafe in Subproblem 3),
the validator stores:
- a failure demo image
- a plain-text explanation
- metrics.json with key numbers

Purpose:
Makes debugging fast and provides transparent evidence for grading.


-------------------------------------------------------------
WHAT WORKS NOW
-------------------------------------------------------------

- One run can generate a full submission evidence bundle:
  - Subproblem 1: path extraction + robot path-following + visuals
  - Subproblem 2: two-way swarm GIF + collision/corridor metrics
  - Subproblem 3: L->R and R->L videos + CSV logs + summaries
- Validation artifacts are stored in a stable, predictable layout.


-------------------------------------------------------------
NOTES
-------------------------------------------------------------

- Subproblem 3 is the most sensitive to tuning and camera characteristics.
  The validator can catch “min distance below Rsafe” early and provide a demo artifact.
- The Phase 6 packaging is designed so you can zip a single results folder and
  hand it in as evidence without hunting for files.

=============================================================
END PHASE 6
=============================================================
